{
  "storeVersion" : 0,
  "docType" : "Note",
  "docTypeVersion" : 5,
  "docId" : "PERWRKXXXXXXU0985",
  "content" : {
    "domain" : null,
    "privateComment" : null,
    "tags" : "",
    "transpositions" : [ {
      "lang" : "FR",
      "title" : "Nexthink : notes unifiées",
      "description" : null,
      "voice" : "fr-FR-Chirp3-HD-Puck",
      "text" : "# Expérience chez Nexthink – Informations consolidées\n\n## Intro\n\nNexthink est une entreprise suisse spécialisée dans la gestion de l’expérience numérique des employés. Son logiciel collecte et analyse en temps réel des données provenant des postes de travail, des applications et des réseaux informatiques. Cette analyse permet aux équipes informatiques de surveiller les performances, de détecter et résoudre les problèmes rapidement, et d’améliorer la satisfaction des utilisateurs finaux.\n\nLa fonctionnalité \"Campaigns\", à laquelle j’ai contribué, permet aux équipes informatiques d’envoyer des enquêtes interactives aux employés via des notifications ciblées. Elle sert à recueillir des retours en temps réel sur l’environnement numérique, à identifier des problèmes et à améliorer l’expérience utilisateur. Les campagnes peuvent être personnalisées avec des paramètres contextuels et adaptées selon les réponses. Les résultats peuvent être consultés via le site principal afin d’effectuer des analyses ou de les intégrer dans des workflows plus complexes, incluant également des campagnes à but informatif.\n\n### Contexte technique\n\nL’application est découpée en deux parties : infrastructure d’un côté, fonctionnalités de l’autre. Chaque module applicatif résultant est confié à une équipe composée d’un Product Manager, d’un Technical Lead, de développeurs et d’un Scrum Master. L’équipe conçoit et maintient des services (Java/Micronaut et TypeScript/React).\n\nL’infrastructure frontend est constituée d’un conteneur de fonctionnalités (micro-frontend).\n\nLes services backend sont déployés sur le cloud et interagissent soit par appel d’API (REST, GraphQL, Proto, RPC...), soit par échange de messages via Kafka.\n\nOutils collaboratifs : Confluence, GitHub, etc.\n\n### Les campagnes\n\nElles sont déclenchées automatiquement par planification ou ciblage automatique, ou manuellement (des paramètres peuvent être précisés lors de l’exécution manuelle).\n\nElles peuvent servir à :\n\n- Recueillir des feedbacks sur des incidents, des déploiements ou des changements.\n- Informer les utilisateurs (mises à jour critiques, sécurité, légalité, etc.).\n- Forcer des réponses dans des contextes sensibles (ex. : consentement RGPD, MFA…).\n\nLes utilisateurs des campagnes sont, chez les clients finaux, les équipes IT.\n\n## Journal\n\n- **2024-12-10** : Modification d’un service afin qu’il récupère ses données depuis un stream Kafka plutôt que depuis la base de données via une *GlobalKTable*.\n\n- **2024-11-13** : Participation à deux *releases* de tous les services de mon équipe : première fois avec soutien, deuxième en autonomie complète.\n\n- **2024-10-10** : Élimination de vulnérabilités (signalées par Dependabot) dans le backend et le frontend : mise à jour de bibliothèques (Node.js, Gradle/Java), correction du code, changement des images de base Docker (« hardened images »).\n\n- **2024-09-30** : Proposition d’une page Confluence pour décrire le processus de production de mon équipe (architecture, conception, développement, tests…).\n\n- **2024-09-28** : La bibliothèque \"Audit Logs\" suscite de l’intérêt.\n\n- **2024-09-05** : Collaboration avec le Tech Lead d’une autre équipe (Simon Lepaster, Data Platform) pour permettre la réutilisation d’une bibliothèque générique (client BCS) :\n- finalisation de l’extraction ;\n- réécriture du client HTTP en Java natif pour supprimer la dépendance à Micronaut ;\n- enrichissement progressif de la bibliothèque par une autre équipe.\n\n- **2024-08-29** : Présentation des deux bibliothèques génériques développées lors d’une réunion d’architecture : le client REST pour BCS et la bibliothèque \"Audit Log\".\n\n- **2024-08-26** : Conception de la gestion des conditions d’affichage d’une campagne sur le poste client via deux nouveaux champs Kafka (\"Do Not Disturb\" et \"Non-Negotiable Protection Period\") :\n- analyse et sélection des flux à modifier ;\n- ajout des champs dans les messages *proto* ;\n- modification des *KTables* dans Kafka Streams ;\n- adaptation des requêtes du *Collector* ;\n- mise en place de tests, communication entre microservices, suivi de projet.\n\n- **2024-08-08** : Rédaction de la documentation détaillée des outils de *Scrum Mastering* développés.\n\n- **2024-07-30** : Support des campagnes ciblant un appareil en plus de l’utilisateur :\n- ajout du champ dans les flux Kafka et l’API OpenAPI ;\n- création d’un *record* Java 21 ;\n- mini-formation interne sur Java 21 ;\n- filtrage des campagnes selon l’appareil cible.\n\n- **2024-07-30** : Contribution à la définition de *guidelines* frontend autour de l’usage de *lodash*.\n\n- **2024-07-01** : Intégration des campagnes obligatoires dans le frontend :\n- adaptation du modèle de données (Java, *proto*) ;\n- ajout de l’option dans les formulaires React.\n\n- **2024-07-01** : Refactorisation des parties critiques liées à l’édition de campagnes et aux requêtes optimisées.\n\n- **2024-06-21** : Déplacement de la bibliothèque client BCS générique dans un dépôt central, à la demande de l’architecte.\n\n- **2024-06-21** : Conception d’un système de logs d’audit :\n- création d’un modèle unifié ;\n- génération de code et de descriptions via réflexivité ;\n- envoi des événements via Kafka après conversion en messages *proto*.\n\n- **2024-06-21** : Stabilisation d’un service Micronaut via l’ordre d’initialisation des *streams* Kafka.\n\n- **2024-06-15** : Ajout du champ `defaultNext` aux questions des campagnes (Java, *proto*, frontend, BCS).\n\n- **2024-06-15** : Ajout d’un cache et d’un *circuit breaker* sur le service *trigger-api*.\n\n- **2024-05-23** : Enrichissement des métriques à partir des *tokens* utilisateur.\n\n- **2024-04-22** : Modification des campagnes retirées pour permettre leur édition complète :\n- spécifications techniques ;\n- validation backend des modifications ;\n- nettoyage et refactorisation du calcul des requêtes.\n\n- **2024-03-22** : Implémentation d’un système d’import/export de campagnes par lot :\n- création d’un composant Java abstrait et générique ;\n- adaptation pour notre équipe.\n\n- **2024-03-09** : Correction d’un crash backend lié à l’absence de validation des campagnes invalides.\nAjout d’une gestion de cas d’erreur et prise de conscience collective de la nécessité d’une validation serveur.\n\n- **2024-02-13** : Développement d’un client REST générique pour BCS à partir d’un fichier OpenAPI, avec appui d’un LLM.\nCe client a servi de base à un service d’import/export agnostique. L’absence de mutualisation entre équipes a mené à des doublons évitables.\n\n- **2024-02-01** : Les outils Scrum développés suscitent l’intérêt d’autres Scrum Masters, qui commencent à les utiliser.\n\n- **2024-01-23** : Développement d’un bandeau React en haut des pages affichant des statistiques de campagne (jauge, graphique 30 jours, détails, lien NQL).\n\n- **2023-10-01** : Amélioration du composant de texte riche pour intégrer des paramètres dynamiques à insérer à l’envoi de la campagne.\n\n- **2023-09-01** : Conception d’un *template* Confluence standardisé pour le suivi de sprint :\n- capacité initiale, livrables, reports, tickets Jira, critères de suivi ;\n- monitoring, grooming, rétrospective, rapports, planification ;\n- documentation rigoureuse des activités du Scrum Master.\n\n- **2023-07-30** : Rédaction de spécifications pour la gestion des permissions granulaires :\n- cartographie des services, synchronisation inter-équipes, composants Java génériques, tickets.\n\n- **2023-07-20** : Mise à jour des composants serveurs pour gérer les permissions granulaires, coordination du plan d’action.\n\n- **2023-05-15** : Intégration avec la « librairie » de campagnes prédéfinies : exposition d’un *endpoint* pour installation et consultation.\n\n- **2023-04-01** : Import/export de campagnes (React + backend léger) :\n- sauvegarde/restauration via JSON ;\n- validation, gestion des conflits, enrichissement du format.\n\n- **2023-02-20** : Ajout de validation HTML dans le backend pour interdire certaines URL/balises issues de l’éditeur de texte riche.\n\n- **2023-02-15** : Automatisation du *build* Jenkins pour prendre en charge les *releases*.\n\n- **2023-02-10** : Intégration du composant React « Content Admin Smart List » avec création d’une *ConfigMap* Kubernetes.\n\n- **2023-01-20** : Création et envoi de nouveaux types de messages vers l’outil de calcul de métriques via Kafka (Java/Micronaut).",
      "exported" : true,
      "llmTranslationLanguageSpecificInstructions" : null,
      "article" : null,
      "ttsMapping" : { },
      "sttMapping" : { },
      "tooltips" : { },
      "bibliographyUrls" : { }
    } ],
    "modificationDate" : "2026-01-01T18:35:55.449844290Z",
    "quality" : "LOW"
  }
}